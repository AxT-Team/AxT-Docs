---
title: 🧶 函数装饰器
date: 2025-08-28 18:56:55
permalink: /axtbot/v2.1/develop/decorator
author:
  name: AxT-Team - Shanshui2024
  link: https://github.com/Shanshui2024
---

# 函数装饰器

## 引子
函数装饰器，本质上是对定义的函数进行修饰，以添加功能、上下文等。

例如，你会在别的项目中遇到这样的代码：
``` python
@on_command("帮助")
async def help(event):
    ...
```

> *只是举个例子，如有雷同 纯属巧合（*

诸如此类，这里 `on_command` 的函数装饰器就给 `help` 函数提供了 `event` 字段，用于事件消息的处理

有关于函数装饰器的具体解释，详见：[Python 函数装饰器 - 菜鸟教程](https://www.runoob.com/w3cnote/python-func-decorators.html)

## 框架内置的装饰器
截至目前，框架共提供了如下几个装饰器：
``` python
from src.Utils.PluginBase import group_add, command
from src.Utils.EventClass import GroupMessageEvent, GroupEvent

@group_add
async def hello_function(event: GroupEvent):
    await event.reply("欢迎使用当前机器人！")

@command(["/hello", "/hi"])
async def hello_command_function(event: GroupMessageEvent):
    await event.reply("Hello World!")
```
好，这一套连招下来就会：

当机器人被拉进群聊后，机器人就会在群内发送 「欢迎使用当前机器人！」

而当用户发送「/hello」或者「/hi」时，机器人就会在群内发送「Hello World!」

> [!NOTE]
> 懂了嘛~不懂的话回去再看一看哦~ ✨
> 
> 本质上就是，当我接收到加群事件就会激活 group_add 装饰的函数 而当我收到群消息时，就会激活 command 装饰的函数
>
> 还不懂嘛？不懂的话问问别人哦（笑

## 函数装饰器的传参
你可能注意到，当我注册多个命令的时候使用了 `[] 列表` 的形式？

一定一定要注意！如果我没有用这种 `dict` 列表的话，第二个命令就会作为 `event` （事件类型过滤器） 的参数从而导致整个代码段无法激活哦

注意啦！ **group_add 函数装饰器不具有任何定义型传参**

那... `command` 呢？

`command` 本身可以传入两个参数，即「命令」和「事件过滤器」

命令，很好解释，就是你要注册到插件管理器的名称

而事件过滤器，则是对于传入的事件进行过滤，例如：
``` python
from src.Utils.PluginBase import command
from src.Utils.EventClass import GroupMessageEvent

@command("test", GroupMessageEvent)
async def only_group(event: GroupMessageEvent):
    pass
```
上述代码段中，我们传入的第二个参数是 `GroupMessageEvent` ，也就意味着，对于 `test` 命令而言，只有群消息 即 `GroupMessageEvent` 事件才会继续以下的逻辑

默认情况下，事件过滤器为 `None` ，即所有消息体事件 (区别于 `group_add` 等群聊事件，消息体事件就是用户确确实实发送了的消息) 都会触发命令逻辑

## 进阶 <Badge text="未完工" type="danger" />
既然我们已经了解了函数装饰器的运作逻辑，那不妨让我们对更多的事件进行处理？

::: warning 注意
框架注册命令时，是否会根据事件不同进行分类的情况尚未知，将在未来进行测试
:::